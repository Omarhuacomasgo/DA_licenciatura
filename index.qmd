---
title: "Tesis_licenciatura"
author: "Omar Huaco Masgo"
date: last-modified     # se actualiza al compilar
lang: es
execute:
  warning: false        # suprime advertencias
  message: false        # suprime mensajes
  echo: true            # (opcional) muestra el código
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    code-overflow: scroll
    df-print: kable
    highlight-style: github
editor: 
  markdown: 
    wrap: 72
---

```{r, include =FALSE}
#| label: setup
#| include: false

knitr::opts_knit$set(
  echo = TRUE,     # muestra el código
  warning = FALSE, # no muestra advertencias
  message = FALSE, # no muestra mensajes
  fig.width = 8,   # ancho de las figuras
  fig.height = 5,  # alto de las figuras
  fig.align = "center", # alinea las figuras al centro
  dpi = 300)            # resolución de las figuras
  
```


```{r setup-libraries, include=FALSE, echo=TRUE, warning=FALSE, message=FALSE}

lapply(c("tidyverse","readxl","writexl","skimr","kableExtra","mice","miceadds","naniar","modelsummary",
  "haven",  "janitor",  "labelled",  "estimatr",  "MASS",  "pscl",  "psych",  "mirt",  "sandwich",
  "lmtest"), library, character.only = TRUE)

```


# Data wrangling

En esta sección se realiza la importación inicial del conjunto de datos y una limpieza preliminar. Se eliminan variables irrelevantes y se estandariza el formato del texto, asegurando uniformidad en minúsculas, espacios eliminados y capitalización consistente.

```{r importaciondedatos}
cdl <- read_xlsx("E:/Bases de datos/datasets_private/Dataset de encuestas.xlsx") %>% 
  dplyr::select(-n_case, -duracion, -zona, -object, -viatype,
         -vianame, -n_vivenda, -nacionalidad, -residencia) %>% 
  dplyr::mutate(
    across(where(is.character),
           ~ .x %>% 
             str_squish() %>%                 # elimina espacios extra
             str_to_lower(locale = "es") %>%  # pasa todo a minúsculas
             str_to_sentence(locale = "es"))  # primera letra en mayúscula
  )
```

## Procesamiento de variables categóricas y numéricas

Esta etapa transforma cadenas de texto en factores y asegura que las variables numéricas tengan el formato adecuado. Además, se especifica un catálogo ordenado para las categorías ordinales, y se aplica una función personalizada para asegurar que estas variables estén correctamente definidas según su nivel de medición.

```{r transformacionglobal}
cdl <- cdl %>% mutate(across(where(is.character), as_factor)) %>%
  mutate(across(where(is.numeric), as.numeric))
```


```{r catalogodenivelesordinales}
# 1. Catálogos de niveles en el orden deseado ------------------------------
niveles <- list(
confianza     = c("Nada", "Poco", "Algo", "Mucho"),
satisfaccion  = c("Muy insatisfecho", "Insatisfecho", "Satisfecho", "Muy satisfecho"),
calidad       = c("Muy malo", "Malo", "Regular", "Bueno", "Muy bueno"),
acuerdo       = c("Muy en desacuerdo", "En desacuerdo","De acuerdo", "Muy de acuerdo"),
aprobacion    = c("Lo desaprueba firmemente", "Lo desaprueba", "No aprueba, pero lo entiende", "Solo lo aprueba", "Lo aprueba firmemente"),
sistema       = c("A veces un gobierno autoritario es mejor", "En realidad me da igual", "Siempre es preferible la democracia"), 
educa         = c("Primaria" , "Secundaria", "Superior"))

```

Definimos una función que nos permita ordenar los niveles de cada variable ordinal tomando en cuenta 

```{r funcion-organizadora-de-listas-ordinales}
ordenar_factor <- function(x, cat_list = niveles, tol = 0.9) {
  # Solo procesa texto / factores
  if (!is.character(x) && !is.factor(x)) return(x)
  
  vals <- unique(na.omit(str_squish(as.character(x))))
  
  # Coincidencia completa
  idx <- detect_index(cat_list, ~ all(vals %in% .x))
  if (idx > 0) {
    return(factor(x, levels = cat_list[[idx]], ordered = TRUE))
  }
  
  # Coincidencia parcial según 'tol'
  idx <- detect_index(cat_list, ~ mean(vals %in% .x) >= tol)
  if (idx > 0) {
    return(factor(x, levels = cat_list[[idx]], ordered = TRUE))
  }
  
  x  # No se encontró catálogo adecuado
}

# Aplicación en todo el data-frame
cdl <- cdl %>% mutate(across(where(~ is.character(.x) | is.factor(.x)), ordenar_factor))

skimr::skim(cdl) %>% as_tibble()
```

## Análisis e imputación de valors perdidos

En esta fase se evalúa la presencia de valores perdidos (NA) mediante métodos gráficos y estadísticos. Se realiza una prueba estadística (MCAR) para evaluar si estos valores faltantes están distribuidos de manera aleatoria o sistemática.


### Detección de patrones

Aquí se resumen visual y estadísticamente los patrones de valores faltantes presentes en las variables del conjunto de datos.

```{r datos-perdidos-naniar}
# 1a. Resumen general
naniar::miss_var_summary(cdl) %>% as_tibble()
```


```{r naniar-ggmiss}
# % de NA por variable
naniar::gg_miss_upset(cdl, nsets = 8)
```


```{r naniar-vismiss}
# patrones conjuntos
vis_miss(cdl, sort_miss = TRUE)             # mapa de calor
```


```{r prueba-mcar}
# 1b. Prueba MCAR (Little)
mcar_test <- naniar::mcar_test(cdl)
mcar_test %>% as_tibble()
```

### Seleccion de variables a imputar

Se clasifican las variables según su tipo (ordinal, nominal, numérico, etc.) para luego definir estrategias específicas de imputación para cada una de ellas.

```{r variables-por-tipo-a-imputar}
# 1. Vector con los ítems de confianza (trust_*)
vars_trust <- names(cdl) %>% 
  str_subset("(?i)^trust")          # (?i) = búsqueda sin distinción de mayúsculas

# 2. Resto de variables ordinales (excluye las trust)
vars_ordinal <- names(cdl)[sapply(cdl, is.ordered)]%>% 
  setdiff(vars_trust)

# 3. Variables nominales 
vars_nominal <- names(cdl)[sapply(cdl, \(x) is.factor(x) && !is.ordered(x))]

# 4. Variables numéricas 
vars_numeric <- names(cdl)[sapply(cdl, is.numeric)]

## Vectores ya definidos

imp_vars <- c(vars_trust, vars_ordinal, vars_nominal, vars_numeric)

## 2. Asegura clase 'ordered' para trust + ordinales ---
cdl <- cdl %>%   mutate(across(all_of(c(vars_trust, vars_ordinal)),
                               ~ factor(.x, ordered = TRUE)))
```


```{r matrix-preditors}
## 3. Matriz de predictores usa quickpred pero baja el umbral a .05 porque el %.NA es pequeño
predM <- quickpred(cdl[imp_vars], mincor = .05, include = "all")

# añade explícitamente edad y sexo como predictores universales
predM[ , c("edad", "sexo")] <- 1   

## 4. Vector de métodos por columna
meth <- make.method(cdl[imp_vars])
```


```{r defnicion-metodos-imputacion}
meth[vars_numeric]               <- "pmm"      # robusto para pequeñas n
meth[c(vars_trust, vars_ordinal)]<- "polr"
meth[vars_nominal] <- if_else(
  sapply(cdl[vars_nominal], nlevels) == 2, "logreg", "polyreg"
)
```

### Proceso de imputación 

Se lleva a cabo la imputación múltiple mediante el método MICE (Multiple Imputation by Chained Equations), especificando métodos de imputación específicos para variables ordinales (polr), nominales (polyreg, logreg) y numéricas (pmm). El resultado es un conjunto de datos completo sin valores perdidos.




```{r imputacio-en-base-a-metodos}
## 5. Imputación 
set.seed(2025)
imp <- mice(cdl[imp_vars],
            m               = 10,      # 10 conjuntos bastan (≤ 10 % NA)
            maxit           = 30,      # converge rápido con pocos NA
            predictorMatrix = predM,
            method          = meth,
            ridge           = 1e-5,    # estabiliza con n = 150
            printFlag       = FALSE)
```

```{r primer-data-set-completo}
# 1. Primer data-set completo (imputación 1)
cdl_imp <- complete(imp, 1)

# 2. Variables que tenían NA en la base original
vars_miss <- names(which(colSums(is.na(cdl)) > 0))
```

### Comparación de datos originales vs. imputados

Aquí se comparan visual y estadísticamente las distribuciones de las variables antes (observadas) y después (imputadas) del proceso de imputación múltiple, con el objetivo de verificar la calidad y coherencia del procedimiento aplicado. La gráfica muestra densidades suavizadas que permiten evaluar si las imputaciones preservan adecuadamente las características esenciales de las variables originales.

El procedimiento seguido es:

1. Selección del primer conjunto imputado:

Se extrae el primer dataset completo obtenido mediante el método de imputación múltiple (complete(imp, 1)).

2. Identificación de variables con valores faltantes:

Se detectan las variables originales que contenían valores perdidos utilizando un conteo de valores NA.

3. Unificación de datos observados e imputados:

Los valores observados (originales) y los valores imputados del primer dataset se combinan en un solo marco de datos, etiquetando cada registro claramente como "Observado" o "Imputado".

4. Transformación y visualización:

Se transforman los datos combinados a formato largo para facilitar la creación de gráficos, generando una densidad para cada variable por separado, comparando ambos tipos de datos.

5. Interpretación visual:

Un ajuste cercano entre las curvas de datos observados e imputados indica que el procedimiento de imputación ha logrado capturar de manera adecuada la estructura original de los datos. Diferencias notables en las densidades sugerirían que la imputación podría haber alterado la distribución original de las variables y que podrían requerirse ajustes adicionales en el modelo o método de imputación seleccionado.


```{r, fig.width=14, fig.height=20}
cdl_imp  <- complete(imp, 1)                          # primer set imputado
vars_miss <- names(which(colSums(is.na(cdl)) > 0))    # columnas con NA

bind_rows(
  cdl      %>% dplyr::select(all_of(vars_miss)) %>% 
               dplyr::mutate(across(everything(), as.numeric),
                     .src = "Observado"),
  cdl_imp  %>% dplyr::select(all_of(vars_miss)) %>% 
               dplyr::mutate(across(everything(), as.numeric),
                     .src = "Imputado")
) %>% 
  pivot_longer(-.src, names_to = "variable", values_to = "valor") %>% 
  drop_na(valor) %>%                                  # elimina NA residuales
  ggplot(aes(x = valor, colour = .src, fill = .src)) +
  geom_density(alpha = .35) +
  facet_wrap(~ variable, scales = "free", ncol = 3) +
  scale_colour_manual(values = c(Observado = "#008B8B",
                                 Imputado  = "#F08080"), name = "") +
  scale_fill_manual(values   = c(Observado = "#008B8B",
                                 Imputado  = "#F08080"), name = "") +
  labs(title = "Densidades observadas vs imputadas",
       y = "Densidad", x = NULL) +
  theme_grey(base_size = 20) +
  theme(legend.position = "bottom")

```

Primero, utilizamos complete(imp, 1) para obtener el primer conjunto de datos completo tras la imputación múltiple. A continuación, identificamos cuáles eran las variables que contenían valores faltantes en la base original, para centrar nuestro análisis en ellas.

```{r creardf-imputados}
# 1. Primer data-set imputado
cdl_imp <- complete(imp, 1)

# 2. Variables que tenían NA en la base original
vars_miss <- names(which(colSums(is.na(cdl)) > 0))
```

Con las variables detectadas, construimos un tibble que, para cada una, calcula la media, mediana y varianza tanto en los datos originales (observados) como en los imputados. Esto nos permite cuantificar posibles cambios en la distribución motivados por la imputación.

Finalmente, redondeamos los estadísticos a tres decimales y desplegamos la tabla con kableExtra, aplicando estilos que mejoran la legibilidad y resaltan las variables analizadas.

```{r analisis-descriptivo-post-imputacion}
# 3. Tabla de medias, medianas y varianzas
tabla_stats <- tibble(variable = vars_miss) %>% 
  rowwise() %>% 
  mutate(
    mean_obs    = mean  (as.numeric(cdl[[variable]]),     na.rm = TRUE),
    median_obs  = median(as.numeric(cdl[[variable]]),     na.rm = TRUE),
    var_obs     = var   (as.numeric(cdl[[variable]]),     na.rm = TRUE),
    mean_imp    = mean  (as.numeric(cdl_imp[[variable]]), na.rm = TRUE),
    median_imp  = median(as.numeric(cdl_imp[[variable]]), na.rm = TRUE),
    var_imp     = var   (as.numeric(cdl_imp[[variable]]), na.rm = TRUE)
  ) %>%   ungroup()



# 4. Imprime en una tabla ordenada
tabla_stats %>% 
  mutate(across(-variable, round, 3)) %>% 
  kableExtra::kable("html", caption = "Estadísticos resumen: valores observados vs imputados") %>% 
  kableExtra::kable_styling(full_width = FALSE,
                            bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
  kableExtra::column_spec(1, bold = TRUE)

```


```{r reemplazo-df-imputado-en-base-original}
## 7. Sustituye primera imputación y guarda ------------
cdl[imp_vars] <- complete(imp, 1)
```

## Análisis descriptivo

Esta sección proporciona estadísticas básicas de tendencia central, dispersión y distribución para describir las variables tras la imputación, ofreciendo una visión general del perfil de los datos.

```{r}

# Prepara la tabla y el título
tbl <- skimr::skim(cdl) %>% as_tibble()

cat("**Resumen de cdl**\n\n")

# Imprime la tabla con scroll vertical
tbl %>%
  kable("html", booktabs = TRUE) %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "400px", width = "100%")
```
### Distribuciones (Gráficos)

Se presentan visualizaciones detalladas que muestran las distribuciones de todas las variables numéricas, facilitando la detección visual de patrones atípicos o tendencias particulares.


```{r variables-numericas, fig.height=14, fig.width=15}
# ── Distribución de todas las variables numéricas
cdl %>% 
  dplyr::select(where(is.numeric)) %>%                       # sólo numéricas
  pivot_longer(everything(), names_to = "variable",
               values_to = "valor") %>% 
  ggplot(aes(x = valor)) +
  geom_histogram(bins = 30, fill = "#1F77B4", colour = "white") +
  facet_wrap(~ variable, scales = "free", ncol = 3) +
  labs(title = "Distribución de variables numéricas",
       x = NULL, y = "Frecuencia") +
  theme_grey(base_size = 14)
```


```{r variable-no-numerica, fig.height=15, fig.width=10}

cdl %>% 
  dplyr::select(where(is.factor)) %>%                       # sólo factores
  mutate(across(everything(), as.character)) %>%     # homogeneiza tipo
  pivot_longer(everything(),
               names_to  = "variable",
               values_to = "valor") %>% 
  drop_na(valor) %>% 
  mutate(valor = str_trunc(valor, 8, side = "right", ellipsis = "")) %>%  # ≤ 8 caracteres
  ggplot(aes(x = valor)) +
  geom_bar(fill = "#1F77B4") +
  facet_wrap(~ variable, scales = "free", ncol = 3) +
  coord_flip() +
  labs(title = "Frecuencias de variables categóricas",
       x = NULL, y = "Conteo") +
  theme_minimal(base_size = 14) +
  theme(axis.text.y = element_text(size = 10),        # texto más grande
        legend.position = "none")

```



# Análisis de variable de interés

En esta sección se estudian en profundidad las variables clave del análisis relacionadas con el apoyo político, definidas en dimensiones y subdimensiones específicas. Se aplican técnicas psicométricas como análisis de confiabilidad (alfa de Cronbach) y Teoría de Respuesta al Ítem (IRT).

## El apoyo político como constructo

### Dimensión 1: Apego a la comunidad

Solo un indicador


### Dimensión 2: Valoración de los principios del régimen al nivel subnacional 

En esta dimensión se utilizan cuatro indicadores. Los referidos a la tolerancia a la oposición se resumen en un índice compuesto

1. Grado de acuerdo con la democracia como mejor régimen (pd_b)
2. Tolerancia a la movilización social en contra del alcalde (vd_1)
3. Tolerancia a la participación electoral de opositores al alcalde (vd_2)
4. Tolerancia al pronunciamiento de opositores al alcalde en medios de comunicación (vd_3)

```{r}
alpha_result <- cdl %>% dplyr::select(vd_1, vd_2, vd_3) %>%  psych::alpha()
alpha_general_df <- as.data.frame(alpha_result$total)
alpha_general_df %>% as_tibble()
```

```{r}
alpha_items_df <- as.data.frame(alpha_result$item.stats) 
alpha_items_df %>% as_tibble()
```


### Dimensión 3:  Evaluación del desempeño del régimen al nivel subnacional



En esta dimensión se utilizan ocho indicadores. Los referidos a la confianza institucional a la oposición se resumen en un índice compuesto

1. Satisfacción con la democracia distrital (swd)
2. Confianza el municipio (trust1)
3. Confianza en el serenazgo  (trust2)
4. Confianza en la DEMUNA  (trust3)
5. Confianza en el servicio de salud distrital (trust4)
6. Confianza en las iglesias del distrito (trust5)
7. Confianza en el serv CIAM,  (trust6)
8. Confianza en la Asociación de Pobladores (trust7)


#### Índice de confianza institucional 


##### Análisis de confiabilidad 

```{r}
# 1. Diccionario de recodificación 
numero <- c("Nada"  = 0,"Poco"  = 1, "Algo"  = 2,  "Mucho" = 3)

# 2. Recodificar → numérico 0–3 y filtrar casos completos -----------------
vars_trust <- cdl %>% dplyr::  mutate(across(dplyr::starts_with("trust"),
           ~ dplyr :: recode(.x, !!!numero)  %>%  as.integer())) %>% 
  dplyr:: select(c(trust1, trust2, trust3, trust4, trust6)) 

# 3. Matriz de correlaciones policóricas -----------------------------------
matriz_rho <- vars_trust %>%   as.data.frame() %>%                        
  psych::polychoric(smooth = TRUE) %>% magrittr::extract2("rho")

matriz_rho %>% as_tibble()

```


```{r}
alpha_result <- vars_trust %>%  psych::alpha()
alpha_general_df <- as.data.frame(alpha_result$total)
alpha_general_df %>% as_tibble()
```

```{r}
alpha_items_df <- as.data.frame(alpha_result$item.stats) 
alpha_items_df %>% as_tibble()
```


### Dimensión 4: Involucramiento con normas y procedimientos

En esta dimensión se emplean cuatro indicadores

1.	Asistencia organizaciones religiosas (nc_1)
2.	Asistencia a organizaciones políticas (nc_2)
3.	Asistencia a juntas vecinales (nc_2)


### Dimensión 5:Autoridades	

1.	Aprobación municipal ( aprobacion)



## La tolerancia al clientelismo

### Análisis de confiabilidad 

```{r}
alpha_result <- cdl %>% dplyr::select(cl_bien, cl_bono, cl_din, cl_emp) %>%  psych::alpha()
alpha_general_df <- as.data.frame(alpha_result$total)
alpha_general_df %>% as_tibble()
```


```{r}
alpha_items_df <- as.data.frame(alpha_result$item.stats) 
alpha_items_df %>% as_tibble()
```


## Partidismo negativo
### Análisis de confiabilidad 

```{r}
alpha_result <- cdl %>% dplyr::select(starts_with("nps")) %>%  psych::alpha()
alpha_general_df <- as.data.frame(alpha_result$total)
alpha_general_df %>% as_tibble()
```


```{r}
alpha_items_df <- as.data.frame(alpha_result$item.stats) 
alpha_items_df %>% as_tibble()
```
### Analisis IRT

#### Espcificación de items 

En esta sección se lleva a cabo el modelado de la dimensión de partidismo negativo mediante un modelo de respuesta graduada (GRM) de un solo factor, para «calibrar» los ítems que miden esa actitud y extraer un puntaje latente estandarizado. El flujo de trabajo es el siguiente:



```{r}
# Se seleccionan los cinco indicadores originales de nps y se convierten a formato numérico, requisito para el paquete mirt:

nps_data1 <- cdl %>% dplyr:: select(nps_1, nps_2, nps_3, nps_4, nps_5) %>%
  mutate(across(everything(), as.numeric))

# Se ajusta un modelo de Respuesta Graduada con un único factor subyacente, que asume que cada ítem discrimina en la misma dimensión latente de partidismo negativo

mod_nps1 <- mirt(data = nps_data1, model = 1, itemtype = "graded", verbose = FALSE)

#Se extraen los parámetros de discriminación (a) y umbrales (b) de cada ítem, se redondean a tres decimales:

params_raw <- coef(mod_nps1, simplify = TRUE)$items %>% as.data.frame() %>%  
  rownames_to_column("item")

params_tbl <- params_raw %>% dplyr::mutate(across(where(is.numeric), round, 3))

params_tbl %>% kable("html", caption = "Parámetros del modelo IRT (GRM – 1 factor)") %>%
  kable_styling(full_width = TRUE)
```
Diagnóstico gráfico del ajuste

Curva de información: muestra en qué niveles del rasgo los ítems aportan más precisión.

Curvas de trazado (trace lines): ilustran la probabilidad de respuesta en cada categoría a lo largo del rasgo latent.

```{r}
plot(mod_nps1, type = "info")
plot(mod_nps1, type = "trace", which.items = 1:5)

summary(mod_nps1)
```

No se obtienen resultados alentadores, ahora probamos retirando un item 


```{r}
nps_data2 <- cdl %>%
  dplyr:: select(nps_1, nps_2, nps_5) %>%  mutate(across(everything(), as.numeric))

mod_nps2 <- mirt(data = nps_data2, model = 1, itemtype = "graded", verbose = FALSE)

params_raw <- coef(mod_nps2, simplify = TRUE)$items %>%  as.data.frame() %>% 
  rownames_to_column("item")

params_tbl <- params_raw %>%  mutate(across(where(is.numeric), round, 3))
```

```{r}
params_tbl %>%  kable("html", caption = "Parámetros del modelo IRT (GRM – 1 factor)") %>%
  kable_styling(full_width = TRUE)

plot(mod_nps2, type = "info")
plot(mod_nps2, type = "trace")

summary(mod_nps2)
```

```{r}
# 1. Escala latente de partidismo negativo (θ) ya estandarizada
cdl <- cdl %>% 
  mutate(theta_nps = mirt::fscores(mod_nps2, method = "EAP") %>%     # puntaje EAP
                     as.numeric() %>%                                # vector
                     scale() %>%                                     # centrado-z
                     as.numeric())                                   # quita atributos
```



Ahora colocamos las nuevas variables en el dataset


```{r}
# 2. Índice de tolerancia al clientelismo (suma de cuatro ítems)
cdl <- cdl %>% 
  mutate(cl_index = rowSums(across(c(cl_bien, cl_emp, cl_din, cl_bono)),
                            na.rm = TRUE))



cdl_t <- cdl %>% 
  # 1. Centrar y escalar numéricas seleccionadas (incluye vd_1, vd_2, vd_3)
  mutate(across(c(edad, d7,cl_index, starts_with("vd_")), 
                ~ as.numeric(scale(.x)))) %>% 
  
  # 2. Reubicar categorías con ≤ 5 casos en "Otro"
  mutate(across(any_of(c("negp", "clien4a")), 
                ~ fct_lump_min(.x, min = 5, other_level = "Otro"))) %>% 
  
  # 3. Índices compuestos
  mutate(
    trust_index         = rowMeans(across(c(trust1, trust2, trust3, trust4, trust6), ~ as.numeric(.x)),    na.rm = TRUE),
    opos_index   = rowMeans(across(c(vd_1, vd_2, vd_3),   ~ as.numeric(.x)), na.rm = TRUE)
  ) %>% 
  
  # 4–6. Recodificaciones de factores y creación de empleo_bin
  mutate(
    partyid    = factor(partyid, levels = c("No", "Si")),
    sexo       = factor(sexo,    levels = c("Masculino", "Femenino")),
    estrato    = factor(estrato, levels = c("Medio", "Medio alto")),
    
    ned = fct_collapse(
      ned,
      "Básica"   = c("Primaria", "Secundaria"),
      "Superior" = "Superior"
    ) %>% 
      factor(ordered = FALSE),
    
    empleo_bin = case_when(
      d6 == "Está trabajando" |
      str_detect(d6, "^No está trabajando justo ahora") ~ "Con empleo",
      TRUE                                              ~ "Sin empleo"
    ) %>% 
      factor(levels = c("Sin empleo", "Con empleo"))
  )
```


# Modelamiento 

# Dimensión 1: Apego a la comunidad

Esta dimensión explora el grado de orgullo y apego que sienten los ciudadanos hacia su comunidad distrital, usando modelos de regresión lineal robustos (OLS con errores estándar corregidos tipo HC3).

## Indicador: Orgullo distrital  

### Especificaciones

```{r}

# Ejemplo con HC3 ya en el ajuste
d1_apego1OLS <- lm_robust(ac_b ~ cl_index,data = cdl_t,  se_type = "HC3") # Efecto independiente del clientelismo
d1_apego2OLS <- lm_robust(ac_b ~ theta_nps, data = cdl_t, se_type = "HC3") # Efecto independiente del NPS
d1_apego3OLS <- lm_robust(ac_b ~ cl_index + theta_nps + ideol + partyid,   data    = cdl_t,   se_type = "HC3") # Control político
d1_apego4OLS <- lm_robust(ac_b ~ cl_index + theta_nps + ideol + partyid +  edad + sexo + ned + empleo_bin + estrato, data  = cdl_t, se_type = "HC3")

```

### Tabulación 

```{r}

modlist <- list(d1_apego1OLS, d1_apego2OLS, d1_apego3OLS, d1_apego4OLS)
names(modlist) <- as.character(seq_along(modlist))

# 1) Guardar en Word
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D1apego_HC3OLS.docx",
  title     = "Apego distrital – Modelos OLS con SE HC3"
)

# 2) Pintar en el informe renderizado
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  title     = "Apego distrital – Modelos OLS con SE HC3")

```


# Dimensión 2: Aprobación de valores del regimen 

Esta dimensión evalúa actitudes relacionadas con el apoyo al régimen democrático y la tolerancia hacia la oposición. Se utilizan regresiones OLS y modelos ordinales para capturar estas relaciones.


## Indicador: Churchill - modelos OLS   

### Especificaciones

```{r message=FALSE, warning=FALSE}

d2_churchill1OLS <- lm_robust(pd_b ~ cl_index, data = cdl_t, se_type = "HC3")
d2_churchill2OLS <- lm_robust(pd_b ~ theta_nps, data = cdl_t, se_type = "HC3")
d2_churchill3OLS <- lm_robust(pd_b ~ cl_index + theta_nps + ideol + partyid,  data = cdl_t, se_type = "HC3")
d2_churchill4OLS <- lm_robust(pd_b ~ cl_index+ theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato, data = cdl_t, se_type = "HC3")

```

### Tabulación

```{r message=FALSE, warning=FALSE}
modlist <- list(d2_churchill1OLS, d2_churchill2OLS, d2_churchill3OLS,  d2_churchill4OLS)

# 1) Guardar en Word
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D2churchill_HC3OLS.docx",
  title     = "Churchill – Modelos OLS con SE HC3"
)

# 2) Pintar en el informe renderizado
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  title     = "Churchill – Modelos OLS con SE HC3"
)

```


## Indicador: Democracia vs dictarua ORDINAL

### Especificaciones

```{r}

cdl_t <- cdl_t %>% 
  mutate(pd_c = factor(
         pd_c,  levels  = c("A veces un gobierno autoritario es mejor","En realidad me da igual",
                  "Siempre es preferible la democracia"),   
      labels  = c("Acepta el autoritarismo", "Indiferente", "Prefiere democracia"),
      ordered = TRUE))
```

```{r}


dim2_ord1 <- MASS::polr (pd_c ~ cl_index, data = cdl_t, Hess = TRUE)
dim2_ord2 <- MASS::polr (pd_c ~ theta_nps, data = cdl_t, Hess = TRUE)
dim2_ord3 <- MASS::polr (pd_c ~ cl_index + theta_nps + ideol + partyid, data = cdl_t, Hess = TRUE)
dim2_ord4 <- MASS::polr (pd_c ~ cl_index + theta_nps + ideol + partyid +  edad + sexo + ned + empleo_bin + estrato, data = cdl_t, Hess = TRUE)

```


### Tabulación

```{r}

modelsummary(
  list("1" = dim2_ord1, "2" = dim2_ord2, "3" = dim2_ord3, "4" = dim2_ord4),
  exponentiate = TRUE,              # exponencia estimates y CI
  statistic    = "conf.int",        # muestra CI en lugar de SE
  conf_level   = 0.95,              # nivel 95%
  fmt          = 2,                 # 2 decimales
  stars        = TRUE,              # + p<.10, * p<.05, etc.
  glance       = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  title        = "Odds Ratios, IC 95% y McFadden’s R²",
  notes        = "IC al 95%; códigos: + p<0.10; * p<0.05; ** p<0.01; *** p<0.001",
  output       = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D2democracia_vs_autho.ORD.docx"
)


modelsummary(
  list("1"=dim2_ord1, "2"=dim2_ord2, "3"=dim2_ord3, "4"=dim2_ord4),
  exponentiate = TRUE,            # exponcia estimates y CI
  statistic    = "conf.int",      # muestra CI en lugar de SE
  conf_level   = 0.95,            # nivel 95%
  fmt          = 2,               # 2 decimales
  stars        = TRUE,            # + p<.10, * p<.05, etc.
  glance       = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  title        = "Democracia vs autoritarismo - Ordinal"
)
```


## Indicador: Tolerancia a la oposición

### Especifcaciones


```{r}

# Ejemplo con HC3 ya en el ajuste
d2_opo1OLS <- lm_robust(opos_index ~ cl_index,data = cdl_t,  se_type = "HC3") # Efecto independiente del clientelismo
d2_opo2OLS <- lm_robust(opos_index~ theta_nps, data = cdl_t, se_type = "HC3") # Efecto independiente del NPS
d2_opo3OLS <- lm_robust(opos_index~ cl_index + theta_nps + ideol + partyid,   data    = cdl_t,   se_type = "HC3") # Control político
d2_opo4OLS <- lm_robust(opos_index~ cl_index + theta_nps + ideol + partyid +  edad + sexo + ned + empleo_bin + estrato, data  = cdl_t, se_type = "HC3")

```


### Tablas


```{r}
modlist <- list(d2_opo1OLS, d2_opo2OLS, d2_opo3OLS, d2_opo4OLS)

# 1) Guardar en Word
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D2oposición_HC3OLS.docx",
  title     = "Tolerancia a la oposición – Modelos OLS con SE HC3"
)

# 2) Pintar en el informe renderizado
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  title     = "Tolerancia a la oposición – Modelos OLS con SE HC3"
)

```


# Dimensión 3: Evaluación del desempeño del régimen

En esta dimensión se analiza la confianza institucional y la satisfacción con la democracia local mediante modelos de regresión lineal robusta y regresión logística binaria.

## Indicador: Confianza institucional 

```{r}
hist(cdl_t$trust_index)
```



### Especificaciones

```{r}

d3_trust1OLS <- lm_robust(trust_index ~ cl_index, data = cdl_t, se_type = "HC3")
d3_trust2OLS <- lm_robust(trust_index ~ theta_nps, data = cdl_t, se_type = "HC3")
d3_trust3OLS <- lm_robust(trust_index~ cl_index + theta_nps + ideol + partyid,  data = cdl_t, se_type = "HC3")
d3_trust4OLS <- lm_robust(trust_index ~ cl_index+ theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato, data = cdl_t, se_type = "HC3")

```

### Tabulación

```{r}
modlist <- list(d3_trust1OLS, d3_trust2OLS, d3_trust3OLS,  d3_trust4OLS)

# 1) Guardar en Word
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D3trust_HC3OLS.docx",
  title     = "Indice de confianza institucional – Modelos OLS con SE HC3"
)

# 2) Pintar en el informe renderizado
modelsummary(
  modlist,
  statistic = "({std.error})",
  stars     = TRUE,
  title     = "Indice de confianza institucional – Modelos OLS con SE HC3"
)

```

## Indicador: Satisfacción con la democracia


### Especificaciones

```{r}
cdl_t <- cdl_t %>%  mutate(swd_d = if_else(swd %in% c("Satisfecho", "Muy satisfecho"),1L, 0L) )
```


```{r message=FALSE, warning=FALSE}

# 1. Modelo simple: cl_index
d3_swd1Logit <- glm(swd_d ~ cl_index,  data   = cdl_t,  family = binomial(link = "logit"))

# 2. Modelo simple: theta_nps
d3_swd2Logit <- glm(  swd_d ~ theta_nps,  data   = cdl_t,  family = binomial(link = "logit"))

# 3. Modelo con controles políticos
d3_swd3Logit <- glm(  swd_d ~ cl_index + theta_nps + ideol + partyid,  data   = cdl_t,  family = binomial(link = "logit"))

# 4. Modelo completo
d3_swd4Logit <- glm(  swd_d ~ cl_index + theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato, data   = cdl_t,
  family = binomial(link = "logit"))
```


### Tabulación


```{r}

modlist <- list(d3_swd1Logit, d3_swd2Logit, d3_swd3Logit, d3_swd4Logit)

# 1) Guardar en Word
modelsummary(
  modlist,
  exponentiate = TRUE,
  statistic    = "conf.int",
  conf_level   = 0.95,
  fmt          = 2,
  stars        = TRUE,
  glance       = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  title        = "SWD – Modelos logit",
  notes        = "IC al 95%; códigos: + p<0.10; * p<0.05; ** p<0.01; *** p<0.001",
  output       = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D3swd_LOGIT.docx"
)


modelsummary(
  modlist,
  exponentiate = TRUE,
  statistic    = "conf.int",
  conf_level   = 0.95,
  fmt          = 2,
  stars        = TRUE,
  glance       = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  title        = "SWD – Modelos logit")

```



# Dimensión 4: Evaluación del desempeño del régimen

Aquí se mide la participación ciudadana en distintas actividades comunitarias (reuniones religiosas, políticas y vecinales), usando modelos ordinales y binarios según corresponda a cada indicador.



```{r}

cdl_t <- cdl_t %>% 
  mutate(
    # Colapsar las categorías
    asist_rel = fct_collapse(nc_1,
      Nunca     = "Nunca", Ocasional = "1 o 2 veces al año",Frecuente = c("1 o 2 veces al mes", "1 vez por semana") ),
    asist_par = fct_collapse(nc_2,Nunca     = "Nunca",Ocasional = c("1 o 2 veces al año", "1 o 2 veces al mes") ),
    asist_vec = fct_collapse(nc_3,Nunca     = "Nunca",Ocasional = "1 o 2 veces al año",
      Frecuente = c("1 o 2 veces al mes", "1 vez por semana"))) %>%
  # Convertir sólo asist_rel y asist_vec en factores ordenados
  mutate( asist_rel = factor(asist_rel, levels = c("Nunca", "Ocasional", "Frecuente"),
                       ordered = TRUE),
    asist_vec = factor(asist_vec,   levels = c("Nunca", "Ocasional", "Frecuente"),
                       ordered = TRUE))

```

## Indicador: Asistencia a reuniones religiosas

### Especificaciones


```{r}

# 1) Asistencia a reuniones religiosas (ordinal)
rel_ord1 <- polr(asist_rel ~ cl_index, data = cdl_t, Hess = TRUE)
rel_ord2 <- polr(asist_rel ~ theta_nps, data = cdl_t, Hess = TRUE)
rel_ord3 <- polr(asist_rel ~ cl_index + theta_nps + ideol + partyid, data = cdl_t, Hess = TRUE)
rel_ord4 <- polr(asist_rel ~ cl_index + theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato,
                 data = cdl_t, Hess = TRUE)
```

### Tabualación

```{r}
# Lista de modelos
modelsummary::modelsummary(
  list("1"=rel_ord1, "2"=rel_ord2, "3"=rel_ord3, "4"=rel_ord4),
  exponentiate  = TRUE,        # odds ratios
  statistic     = "conf.int",  # IC en lugar de SE
  conf_level    = 0.95,
  fmt           = 2,
  stars         = TRUE,        # + p<.10; * p<.05; etc.
  glance        = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
 output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D4religion_ORD.docx",
  title    = "Asistencia a reuniones religiosas- Modelos Ordinales"
)

modelsummary::modelsummary(
  list("1"=rel_ord1, "2"=rel_ord2, "3"=rel_ord3, "4"=rel_ord4),
  exponentiate  = TRUE,        # odds ratios
  statistic     = "conf.int",  # IC en lugar de SE
  conf_level    = 0.95,
  fmt           = 2,
  stars         = TRUE,        # + p<.10; * p<.05; etc.
  glance        = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  title    = "Asistencia a reuniones religiosas- Modelos Ordinales")
```

## Indicador: Asistencia a reuniones con partidos políticos

```{r}
table(cdl_t$asist_par)
```

### Especificaciones

```{r}
library(brglm2)       # brglm() para logit Firth
library(modelsummary) # tabulación
library(pscl)         # pR2
library(pROC)         # AUC
library(PRROC)        # AUPRC
library(DescTools)    # BrierScore
library(tibble)       # add_column
```


```{r}
par_log1 <- glm(asist_par ~ cl_index,  data   = cdl_t,family = binomial("logit"),  method = brglm2::brglmFit,
                type   = "AS_mean")

par_log2 <- glm(asist_par ~ theta_nps,  data   = cdl_t,       family = binomial("logit"),
                method = brglm2::brglmFit,
                type   = "AS_mean")

par_log3 <- glm(asist_par ~ cl_index + theta_nps + ideol + partyid,  data   = cdl_t,    family = binomial("logit"),
                method = brglm2::brglmFit,
                type   = "AS_mean")

par_log4 <- glm(asist_par ~ cl_index + theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato,
                data   = cdl_t,
                family = binomial("logit"),
                method = brglm2::brglmFit,
                type   = "AS_mean")

models <- list("1" = par_log1, "2" = par_log2, "3" = par_log3, "4" = par_log4)


add_quality <- function(m) {
  pr <- predict(m, type = "response")
  auc   <- as.numeric(pROC::roc(cdl_t$asist_par, pr)$auc)
  auprc <- PRROC::pr.curve(scores.class0 = pr[cdl_t$asist_par == 1],
                           scores.class1 = pr[cdl_t$asist_par == 0])$auc.integral
  brier <- DescTools::BrierScore(m)
  tibble(
    AIC         = AIC(m),
    BIC         = BIC(m),
    McFadden_R2 = pscl::pR2(m)["McFadden"],
    AUC         = round(auc, 2),
    AUPRC       = round(auprc, 2),
    Brier       = round(brier, 3)
  )
}
```

### Tabulación


```{r}

modelsummary(
  models,
  exponentiate = TRUE,          # odds ratios
  statistic    = "conf.int",
  stars        = TRUE,   # IC 95 %
  fmt          = 2,
  glance       = list(~ add_quality(.)),
  title        = "Logit penalizado (Firth) – Asistencia partidaria",
  notes        = paste(
    "Odds ratios (IC 95 %); AIC, BIC, pseudo-R² de McFadden,",
    "AUC-ROC, AUPRC y Brier score incluidos para eventos raros"
  ),
  output       = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D4partidos_FIRTH.docx"
)
```



## Indicador: Asistencia a juntas vecinales (ordinal)

### Especificaciones

```{r}
# 3) Asistencia a juntas vecinales (ordinal)
vec_ord1 <- polr(asist_vec ~ cl_index, data = cdl_t, Hess = TRUE)
vec_ord2 <- polr(asist_vec ~ theta_nps,  data = cdl_t, Hess = TRUE)
vec_ord3 <- polr(asist_vec ~ cl_index + theta_nps + ideol + partyid,data = cdl_t, Hess = TRUE)
vec_ord4 <- polr(asist_vec ~ cl_index + theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato,  data = cdl_t, Hess = TRUE)

```

### Tabulación

```{r}
# Lista de modelos
modelsummary::modelsummary(
  list("1"=vec_ord1, "2"=vec_ord2, "3"=vec_ord3, "4"=vec_ord4),
  exponentiate  = TRUE,        # odds ratios
  statistic     = "conf.int",  # IC en lugar de SE
  conf_level    = 0.95,
  fmt           = 2,
  stars         = TRUE,        # + p<.10; * p<.05; etc.
  glance        = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  title    = "Asistencia a reuniones vecinales- Modelos Ordinales"
)

modelsummary::modelsummary(
  list("1"=vec_ord1, "2"=vec_ord2, "3"=vec_ord3, "4"=vec_ord4),
  exponentiate  = TRUE,        # odds ratios
  statistic     = "conf.int",  # IC en lugar de SE
  conf_level    = 0.95,
  fmt           = 2,
  stars         = TRUE,        # + p<.10; * p<.05; etc.
  glance        = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D4vecinos_ORD.docx",
  title    = "Asistencia a reuniones vecinales- Modelos Ordinales")
```


# Dimensión 5: Autoridades

Esta dimensión examina específicamente la aprobación municipal utilizando modelos logísticos binarios para determinar qué factores están asociados a la aprobación del gobierno local.

## Indicador: Aprobación municipal



```{r}

cdl_t <- cdl_t %>%  mutate(aprob_d = if_else(aprobacion == "Si", 1L, 0L))

```

### Especificaciones 
```{r}

apr_log1 <- glm(aprob_d ~ cl_index, data = cdl_t, family = binomial(link = "logit"))
apr_log2 <- glm(aprob_d ~ theta_nps, data = cdl_t, family = binomial(link = "logit"))
apr_log3 <- glm(aprob_d ~ cl_index + theta_nps + ideol + partyid,  data = cdl_t, family = binomial(link = "logit"))
apr_log4 <- glm(aprob_d ~ cl_index + theta_nps + ideol + partyid + edad + sexo + ned + empleo_bin + estrato, data = cdl_t, family = binomial(link = "logit"))
```

### Tabulación

```{r}
modelsummary::modelsummary(
  list("1"=apr_log1, "2"=apr_log2, "3"=apr_log3, "4"=apr_log4),
  exponentiate  = TRUE,        # odds ratios
  statistic     = "conf.int",  # IC en lugar de SE
  conf_level    = 0.95,
  fmt           = 2,
  stars         = TRUE,        # + p<.10; * p<.05; etc.
  glance        = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  # output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D5apr_binomial.docx",
  title    = "Aprobación municial - Modelos binarios")

modelsummary::modelsummary(
  list("1"=apr_log1, "2"=apr_log2, "3"=apr_log3, "4"=apr_log4),
  exponentiate  = TRUE,        # odds ratios
  statistic     = "conf.int",  # IC en lugar de SE
  conf_level    = 0.95,
  fmt           = 2,
  stars         = TRUE,        # + p<.10; * p<.05; etc.
  glance        = list(~ tibble(
    Observaciones = nobs(.),
    McFadden_R2   = pscl::pR2(.)["McFadden"]
  )),
  output    = "E:/Rstudio projects/DA_licenciatura/Exports/Tables/D5apr_binomial.docx",
  title    = "Aprobación municial - Modelos binarios")
```

# Graficos

## Confianza institucional


```{r, fig.height=15, fig.width=10}
library(tidyverse)

conf_long <- cdl_t %>% 
  pivot_longer(
    cols      = c(trust1, trust2, trust3, trust4, trust5, trust6, trust7),
    names_to  = "institucion",
    values_to = "confianza"
  ) %>% 
  mutate(
    institucion = recode(institucion,
      trust1 = "Municipio",
      trust2 = "Serenazgo",
      trust3 = "DEMUNA",
      trust4 = "Serv.salud",
      trust5 = "Iglesias",
      trust6 = "CIAM",
      trust7 = "Asoc.pobladores"
    ),
    confianza = factor(confianza,
                       levels   = c("Nada", "Poco", "Algo", "Mucho"),
                       ordered  = TRUE)
  )

# 2) Media y mediana de cl_index por nivel de confianza e institución
cl_summary <- conf_long %>% 
  group_by(institucion, confianza) %>% 
  summarise(
    n           = n(),
    media_cli   = mean(cl_index, na.rm = TRUE),
    mediana_cli = median(cl_index, na.rm = TRUE)
  ) %>% 
  arrange(institucion, desc(confianza))   # pone "Mucho" arriba

# 3) Idem para partidarismo negativo (theta_nps)
pn_summary <- conf_long %>% 
  group_by(institucion, confianza) %>% 
  summarise(
    n            = n(),
    media_pn     = mean(theta_nps, na.rm = TRUE),
    mediana_pn   = median(theta_nps, na.rm = TRUE)
  ) %>% 
  arrange(institucion, desc(confianza))
```


```{r, fig.height=15, fig.width=10}
levels_inst <- c("Municipio",
                 "Serenazgo",
                 "DEMUNA",
                 "Serv.salud",   # asegúrate de usar el mismo texto
                 "Iglesias",
                 "CIAM",
                 "Asoc.pobladores")

conf_long <- cdl_t %>% 
  pivot_longer(cols = c(trust1:trust7),
               names_to  = "institucion",
               values_to = "confianza") %>% 
  mutate(
    institucion = recode(institucion,
      trust1 = "Municipio",
      trust2 = "Serenazgo",
      trust3 = "DEMUNA",
      trust4 = "Serv.salud",
      trust5 = "Iglesias",
      trust6 = "CIAM",
      trust7 = "Asoc.pobladores"
    ),
    institucion = factor(institucion, levels = levels_inst),   # <- ❶
    confianza   = factor(confianza,
                         levels  = c("Nada", "Poco", "Algo", "Mucho"),
                         ordered = TRUE)
  )
```


```{r, fig.height=15, fig.width=10}
conf_long %>% 
  pivot_longer(cols = c(cl_index, theta_nps),
               names_to  = "predictor",
               values_to = "valor") %>% 
  mutate(predictor = recode(predictor,
                            cl_index  = "Tolerancia al clientelismo",
                            theta_nps = "Partidismo negativo")) %>% 
  ggplot(aes(y = confianza, x = valor)) +
  geom_boxplot(fill = "#A1B3D1") +
  facet_grid(institucion ~ predictor, scales = "free_x") +
  labs(x = NULL, y = "Confianza") +
  theme_gray(base_size = 13)

```

